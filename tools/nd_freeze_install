#!/usr/bin/python
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:
#
import argparse
import glob
import logging
import os
import re
import requests
import subprocess

parser = argparse.ArgumentParser()
parser.add_argument(
    "packages",
    help="package and version to install (e.g. git=2.17.1)",
    nargs="+",
    metavar="package=version"
)
parser.add_argument(
    "-n, --no-updates",
    help=("Make the snapshot repositories available but skip"
        "the package update step, leaving the system as is."),
    action="store_true",
    dest="no_updates"
)
parser.add_argument(
    "-d, --debug",
    help="print debugging informaiton to the screen",
    action="store_true",
    dest="debug"
)
parser.add_argument(
    "-t, --trust-repos",
    help=("Update untrusted repos. For repos whose apt keys are invalid, "
        "go ahead and use the repo rather thanfailing by default. "
        "USE CAUTIOUSLY!"),
    action="store_true",
    dest="trust_repos"
)
args = parser.parse_args()

if (args.debug):
    logging.basicConfig(level=logging.DEBUG)
else:
    logging.basicConfig(level=logging.INFO)


# Run a shell command
#
# Parameters
# ----------
# command
#   string : command to run in shell
#
# Returns
# -------
# string : STDOUT
#
def exec_shell(command):
    logging.debug("Executing shell command: '{}'".format(command))
    s = subprocess.Popen(command.split(), stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT)
    stdout, stderr = s.communicate()
    logging.debug("Command STDOUT: {}".format(stdout))
    logging.debug("Command STDERR: {}".format(stderr))
    return stdout


# Run apt-get update command
#
def run_apt_get_update():
    logging.info("Refreshing apt cache")
    switch = ""
    if (is_minimum_apt_version("1.4.8")):
        switch = "--no-allow-insecure-repositories"
    stdout = exec_shell("apt-get update {}".format(switch))
    missing_key = re.findall(r'NO_PUBKEY (\w+)', stdout)
    if (len(missing_key) > 0):
        logging.info("Missing public key for {}, attempting to get key".format(
            missing_key[0]))
        exec_shell(("apt-key adv --recv-keys --keyserver "
            "pool.sks-keyservers.net 0x{}").format(missing_key[0]))
        logging.info("Successfully retrieved public key, re-running apt update")
        exec_shell("apt-get update {}".format(switch))


# Scrape the appropriate snapshot timestamps from the repo websites based on
# the package name and version
#
# Parameters
# ----------
# packages
#   list : list of packages to get timestamps
#
# Returns
# -------
# list : snapshot repo urls that go /etc/apt/sources.list.d
#
def get_repo_urls(packages):
    urls = []
    url_template = "http://{}/archive/{}/{}/"

    for p in packages:

        (package, version) = p.split("=")

        # First check, neurodebian
        domain = "snapshot-neuro.debian.net"
        repo = "neurodebian"
        timestamp = get_timestamp(domain, repo, package, version)
        if timestamp:
            urls.append(url_template.format(domain, repo, timestamp))

        # If not found in NeuroDebian snapshot, try Debian
        if not timestamp:
            domain = "snapshot.debian.org"
            repo = "debian"
            timestamp = get_timestamp(domain, repo, package, version)
            if timestamp:
                urls.append(url_template.format(domain, repo, timestamp))

        # No repo found so complain
        if not timestamp:
            logging.info("No snapshot repository found for {}".format(p))

    return urls


# Function returns a hash of information for each source that we want
# to include as a snapshot repo.
#
# Returns
# -------
# sources
#     dict : The sources retrieved from apt-cache policy that need to be
#       written to the sources file.
#
def get_sources():
    sources = {}

    logging.info("Discovering installed repository sources")
    run_apt_get_update()
    files = glob.glob("/var/lib/apt/lists/*Release")
    for file in files:
        source = {}
        with open(file, "r") as f:
            lines = f.readlines()
        for line in lines:
            matches = re.findall(r'^([a-zA-Z][^:]*):[\ ]+(\S.*)$', line)
            if len(matches) > 0:
                source[matches[0][0]] = matches[0][1]
        if source["Origin"] in ["Debian", "NeuroDebian", "Debian Backports"]:
            msg = "Found {Label} {Codename} with components {Components}"
            logging.debug(msg.format(**source))
            for component in source["Components"].split():
                codename = source["Codename"]
                matches = re.findall(r'(\S+)\/(\S+)', component)
                if len(matches) > 0:
                    codename = "{}/{}".format(source["Codename"], matches[0][0])
                    component = matches[0][1]
                key = "{}|{}|{}".format(source["Label"], source["Codename"],
                    component)
                sources[key] = {
                    "Origin": source["Origin"],
                    "Label": source["Label"],
                    "Codename": codename,
                    "Component": component
                }
    return sources


# Function writes out the necessary lines to the /etc/apt/sources.list.d/snapshot.sources.list
# file. The source written to the sources file is pointed to the next snapshot
# taken after the date provided by the user. To get the "next" snapshot timestamp
# we pull the HTML file of the current snapshot and scrape the next timestamp.
#
# Parameters
# ----------
# snapshots_sources_file
#     string : Path to snapshot sources file.
# repo_url
#     string : Sources url for the snapshot repo.
# sources
#     dict : The sources retrieved from /var/lib/apt/lists/*Release policy that
#            need to be written to the sources file.
#
def write_snapshot_sources(snapshot_sources_file, repo_url, sources):
    trusted_option = ""
    if args.trust_repos and is_minimum_apt_version("0.9.0"):
        trusted_option = " [trusted=yes]"
    with open(snapshot_sources_file, "a+") as f:
        for key in sources.keys():
            if ("snapshot-neuro.debian.net" in repo_url
                    and sources[key]["Label"] == "NeuroDebian") \
                    or ("snapshot.debian.org" in repo_url
                    and sources[key]["Label"] == "Debian") \
                    or (sources[key]["Label"] == "Debian-Security"):

                # Hold off updating security archive until after the
                # debian-archive-keyring package is updated.
                line_prefix = ""
                if sources[key]["Label"] == "Debian-Security":
                    line_prefix = "#"

                source_line = "deb{} {} {} {}".format(
                    trusted_option,
                    repo_url,
                    sources[key]["Codename"],
                    sources[key]["Component"]
                )
                f.write("{}{}\n".format(line_prefix, source_line))
                logging.debug("Adding '{}' to {}".format(source_line,
                    snapshot_sources_file))


# Update the installed packages to their snapshot versions
#
# Parameters
# ----------
# packages
#     list : List of installed packages
#
def update_packages(packages):
    if len(packages) > 0:
        packages_to_update = " ".join(packages)
        logging.info("UPDATING: {}".format(packages_to_update))
        downgrade_switch = "--allow-downgrades" if is_minimum_apt_version("1.1.57") else ""
        remove_switch = "--allow-remove-essential" if is_minimum_apt_version("1.1") else ""
        force_switch = "" if downgrade_switch or remove_switch else "--force-yes"
        params = [
            force_switch,
            downgrade_switch,
            remove_switch,
            packages_to_update
        ]
        exec_shell("apt install --fix-broken {} {} {} -y".format(*params))
        exec_shell(("export DEBIAN_FRONTEND=noninteractive; apt-get install" +
            " --no-install-recommends {} {} {} -y {}").format(*params))


# Test system for minimum version of apt package
#
# Parameters
# ----------
# version
#     string : apt version number to test
#
# Returns
# -------
# boolean : true if system version is >= to the parameter version
#
def is_minimum_apt_version(version):
    result = exec_shell("dpkg -l apt")
    matches = re.findall(r'ii\s+apt\s+(\S+)', result)
    if len(matches) > 0:
        logging.debug("Found apt version {}".format(matches[0]))
        command = ["dpkg", "--compare-versions", matches[0], "ge", version]
        try:
            result = subprocess.check_call(command)
            if result == 0:
                return True
        except subprocess.CalledProcessError:
            pass
    return False


# Scrape the snapshot timestamp from the web for a given package version
#
# Parameters
# ----------
# domain
#     string : URL domain of snapshot website
# repo
#     string : "neurodebian" or "debian"
# package
#     string : package name
# version
#     string : package version
#
# Returns
# -------
# string : timestamp of snapshot repo if found. Otherwise None
#
def get_timestamp(domain, repo, package, version):
    url = "http://{}/package/{}/{}/".format(domain, package, version)
    logging.debug("Scraping {} for {}={}".format(url, package, version))
    response = requests.get(url)
    if response.status_code == 200:
        pattern = "/archive/{}/([0-9TZ]+)/pool/main/[a-z]/{}/".format(repo,
            package)
        matches = re.findall(pattern, response.text)
        if len(matches) > 0:
            logging.debug("Scraped timestamp: {}".format(matches[0]))
            return matches[0]


if __name__ == '__main__':

    # Set apt setting to allow "outdated" repositories.
    if not os.path.exists("/etc/apt/apt.conf.d/10no--check-valid-until"):
        exec_shell("echo 'Acquire::Check-Valid-Until \"0\";' > /etc/apt/apt.conf.d/10no--check-valid-until")

    # So we later on could make a decision either we need to clean up after ourselves
    # Rely on having a Release file, since cannot be just * since there could be
    # empty partial/ directory
    apt_release_list = glob.glob("/var/lib/apt/lists/*Release")

    snapshots_sources_file = '/etc/apt/sources.list.d/snapshots.sources.list'

    if os.path.exists(snapshots_sources_file):
        exec_shell("rm {}".format(snapshots_sources_file))
        run_apt_get_update()

    repo_urls = get_repo_urls(args.packages)
    sources = get_sources()
    if sources:
        for repo_url in repo_urls:
            write_snapshot_sources(snapshots_sources_file, repo_url, sources)
    else:
        logging.info("No valid sources found to get snapshots.")
        exit(1)

    if args.no_updates:
        logging.info("Packages were not updated")
        # Enable security archives
        exec_shell("sed -i 's:#::g' {}".format(snapshots_sources_file))
    else:
        # Update debian-archive-keyring first
        update_packages(["debian-archive-keyring"])
        # Enable security archives
        exec_shell("sed -i 's:#::g' {}".format(snapshots_sources_file))
        run_apt_get_update()
        # Update all the packages
        update_packages(args.packages)

    if len(apt_release_list) > 0:
        logging.info("Cleaning up APT lists because originally there were none")
        exec_shell("rm -rf /var/lib/apt/lists/*")

    exit(0)
